#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
/**
  仅用0和其他数字交换的形式对1到N-1进行排序，最少需要交换几次
  输入：10
        3 5 7 2 6 4 9 0 8 1
  输出：9

  思路：脑海中要出现寻父链表，没有0参与的链表则多两次交换 (此题一开始的感觉很重要，程序很短小却想得比较久，按要求来讲应该属于秒杀题)
  细想简单验证： 0 <-> 1          0 <-> 3
                 1 <-> 2          0 <-> 2
                 2 <-> 3  等价于  0 <-> 1   只要有0参与，总交换次数不变！
*/
int n;
int main(){
    scanf("%d",&n);
    int a[n];
    for(int i = 0 ; i < n; i++){
        scanf("%d",&a[i]);
    }
    int num = 0;
    for(int i = 0 ; i < n; i++){
        if(a[i] != i){//如果元素没有放对位置
            while(a[i] != i){//直到找到该位置对应元素（为什么一定能找到？因为a[i]是错的，证明位置j=a[i]上的元素也是错的，因此交换必能确定其中一个数的位置，加之for循环，那么最终一定能确定所有元素的位置）
                swap(a[i],a[a[i]]);//把a[i]换到它应该在的位置，那么a[j]原来肯定也是错的，接下来判断a[j]是不是i
                num += 1;
            }
            if(i!=0) num += 2;//第0位有0参与，其他位均多两次交换
        }
    }
    cout<<num<<endl;
}
